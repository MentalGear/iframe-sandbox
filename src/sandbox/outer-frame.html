<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sandbox Outer Frame</title>
    <style>
        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; }
        #inner { width: 100%; height: 100%; border: none; }
    </style>
</head>
<body>
    <iframe id="inner" sandbox="allow-scripts allow-same-origin" src="inner-frame.html"></iframe>

    <script>
        /**
         * Outer Frame - SW registration and message relay.
         * All code wrapped in IIFE to prevent global exposure.
         */
        (function() {
            'use strict';
            
            const innerFrame = document.getElementById('inner');
            const HOST_ORIGIN = window.location.origin.replace('sandbox.', '');

            // Send status updates to host (for playground display)
            function sendStatus(status, level = 'log') {
                window.parent.postMessage({
                    type: 'LOG',
                    source: 'outer',
                    level: level,
                    area: 'system',
                    message: status,
                    timestamp: Date.now()
                }, HOST_ORIGIN);
            }

            // 1. Service Worker registration
            if ('serviceWorker' in navigator) {
                sendStatus('SW: registering...');
                
                navigator.serviceWorker.register('/outer-sw.js', { scope: '/', updateViaCache: 'none' })
                    .then(reg => {
                        const checkState = () => {
                            if (reg.active) {
                                sendStatus('SW: active');
                                window.parent.postMessage('READY', HOST_ORIGIN);
                            } else {
                                setTimeout(checkState, 200);
                            }
                        };
                        checkState();
                    })
                    .catch(err => {
                        sendStatus('SW: registration failed - ' + err.message, 'error');
                        console.error("SW registration failed:", err);
                    });
                
                // Listen for messages from SW (network/security events)
                navigator.serviceWorker.addEventListener('message', (event) => {
                    if (event.data?.type === 'LOG') {
                        window.parent.postMessage(event.data, HOST_ORIGIN);
                    }
                });

                // --- SECURITY HARDENING (Defense Trio) ---
                
                // 1. Monkey-Patch register/unregister to prevent tampering
                try {
                    // Save original references if we need them (but we assume setup is done)
                    // Block unregister
                    const ServiceWorkerRegistrationProto = ServiceWorkerRegistration.prototype;
                    ServiceWorkerRegistrationProto.unregister = function() {
                        console.warn("[Sandbox] Blocked attempt to unregister Service Worker");
                        return Promise.reject(new Error("Blocked by Sandbox"));
                    };
                    Object.freeze(ServiceWorkerRegistrationProto);

                    // Block new registrations
                    const ServiceWorkerContainerProto = ServiceWorkerContainer.prototype;
                    const originalRegister = ServiceWorkerContainerProto.register;
                    ServiceWorkerContainerProto.register = function(url, options) {
                        // Allow only our authorized SW
                        if (url && (url === '/outer-sw.js' || url.endsWith('/outer-sw.js'))) {
                            return originalRegister.apply(this, arguments);
                        }
                        console.warn("[Sandbox] Blocked attempt to register unauthorized Service Worker:", url);
                        return Promise.reject(new Error("Blocked by Sandbox"));
                    };
                    Object.freeze(ServiceWorkerContainerProto);
                } catch(e) {
                    console.error("[Sandbox] Failed to apply SW monkey-patches", e);
                }

                // 2. Freeze key globals to prevent prototype poisoning
                // (Note: aggressive freezing can break libs, but safe for outer-frame which runs no user code)
                try {
                    Object.freeze(navigator.serviceWorker);
                    // We can't easily freeze window.parent, but we locked the API.
                } catch(e) { /* ignore */ }

                // 3. MutationObserver to allow ONLY our inner-frame
                // This prevents attackers from spawning new clean iframes to bypass our monkey-patches
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach(m => {
                        m.addedNodes.forEach(node => {
                            if (node.tagName === 'IFRAME' && node.id !== 'inner') {
                                console.warn("[Sandbox] Blocked unauthorized iframe creation");
                                node.remove();
                            }
                        });
                    });
                });
                observer.observe(document, { childList: true, subtree: true });
                
                // Also proxy createElement to throw early (faster feedback)
                const originalCreateElement = document.createElement;
                document.createElement = function(tagName, options) {
                    if (tagName && tagName.toLowerCase() === 'iframe') {
                        console.warn("[Sandbox] Blocked document.createElement('iframe')");
                        throw new Error("Blocked by Sandbox");
                    }
                    return originalCreateElement.apply(this, arguments);
                };
                
                // -----------------------------------------
            } else {
                sendStatus('SW: not supported', 'error');
            }

            // 2. Messages from Host -> forward to inner frame or SW
            window.addEventListener('message', (event) => {
                if (event.origin !== HOST_ORIGIN) return;
                
                const data = event.data;
                if (!data) return;

                if (data.type === 'EXECUTE') {
                    innerFrame.contentWindow.postMessage(data, "*");
                } else if (data.type === 'SET_NETWORK_RULES') {
                    if (navigator.serviceWorker.controller) {
                        navigator.serviceWorker.controller.postMessage(data);
                    }
                    // Handle execution policy (inline to prevent external access)
                    if (data.rules?.execution) {
                        const execution = data.rules.execution;
                        const attrs = ['allow-same-origin'];
                        if (execution.scripts !== false) attrs.push('allow-scripts');
                        if (execution.formSending !== false) attrs.push('allow-forms');
                        if (execution.popups === true) attrs.push('allow-popups');
                        if (execution.modals !== false) attrs.push('allow-modals');
                        if (execution.downloads === true) attrs.push('allow-downloads');
                        const newSandbox = attrs.join(' ');
                        if (innerFrame.sandbox !== newSandbox) {
                            innerFrame.sandbox = newSandbox;
                            sendStatus('Sandbox attributes: ' + newSandbox);
                        }
                    }
                } else if (data.type === 'REGISTER_HEARTBEAT_PORT') {
                    if (navigator.serviceWorker.controller && event.ports[0]) {
                        // Forward the port to the Service Worker
                        navigator.serviceWorker.controller.postMessage(data, [event.ports[0]]);
                    }
                } else if (data.type === 'RESET') {
                    navigator.serviceWorker.getRegistrations().then(regs => {
                        Promise.all(regs.map(r => r.unregister())).then(() => {
                            window.parent.postMessage({ type: 'RESET_COMPLETE' }, HOST_ORIGIN);
                        });
                    });
                }
            });

            // 3. Messages from Inner Frame -> forward to Host
            window.addEventListener('message', (event) => {
                if (event.source === innerFrame.contentWindow) {
                    if (event.data?.type === 'LOG' || event.data === 'READY') {
                        window.parent.postMessage(event.data, HOST_ORIGIN);
                    }
                }
            });
        })();
    </script>
</body>
</html>
